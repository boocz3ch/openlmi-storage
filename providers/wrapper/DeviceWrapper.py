# Cura Storage Provider
#
# Copyright (C) 2012 Red Hat, Inc.  All rights reserved.
#
# This program is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 2 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program.  If not, see <http://www.gnu.org/licenses/>.

"""
As shown in :doc:`smis-block`, all storage layers represented by StoragePools
are quite similar. Each StoragePool has some associated StorageExtents, all
pools except the primordial one are allocated from underlying pools and the
associated extents are based on underlying extents.

Anaconda storage module is arranged in similar way - each storage layer is
implemented as Anaconda storage device.

Therefore we created a python DeviceWrapper class, which wraps an Anaconda
storage device type (e.g. RAID) and provides all necessary CIM classes for it:

- StorageExtent
- StoragePool
- StorageCapabilities
- BasedOn
- AllocatedFrom
- AssociatedComponentExtent
- ElementCapabilities

.. figure:: pic/device-wrapper.png

   Instance diagram of objects generated by one DeviceWrapper instance
   Grayed objects are out of scope of the DeviceWrapper.

Subclassing this DeviceWrapper, one can easily create all these classes,
representing new storage layer (i.e. Anaconda storage device).

There is WrapperManager class instance, which holds all existing DeviceWrapper
subclasses and is able to return appropriate DeviceWrapper for an Anaconda
storage device and a vice versa, provide Anaconda storage device instance for
given CIM instance.

With DeviceWrappers for every Anaconda storage device it is easy to stack any
storage devices on top of any other - e.g. RAID on top of LVM on top of RAID.
DeviceWrapper and WrapperManager greatly simplifies composition of proper CIM
associations between various layers.

The DeviceWrapper not only provides read-only access, it is used also to create
StoragePools (i.e. create new storage device) and allocate LogicalDisk.
Subclasses should override canCreatePool() and createPool() methods to
create StoragePools of Anaconda storage devices types they wrap.
LogicalDisks are allocated by createLogicalDisk(), which can be overriden
by subclasses if the default behaviour is not suitable for particular
Anaconda storage device type.
"""
import pywbem
import pyanaconda.storage
from common import *
from WrappedStorageCapabilities import WrappedStorageCapabilities

class DeviceWrapper(object): 
    """
    Abstract wrapper of anaconda.storage.device.

    A DeviceWrapper is abstract class. A subclass of this class wraps one
    specific Anaconda storage device type (e.g.
    pyanaconda.storage.devices.MDRaidArrayDevice) and implements functionality
    for all the above CIM classes. All these CIM classes must have uniqiue name,
    i.e. CIM class name of RAID's StoragePools must be different to volume
    group's StoragePools CIM class names.

    CIM providers for the above classes are in Wrapped*.py modules in this
    directory. The Wrapped*.py modules provide *common* functionality,
    which is exactly the same for all Anaconda device types, while
    DeviceWrapper subclasses provide *specific* functionality for each
    Anaconda device type.

    Subclasses of this DeviceWrapper class should override appropriate methods

    By default, for one concrete Anaconda storage device a DeviceWrapper
    subclass generates:

    - one StoragePool
    - one StorageExtent (+ its association to the StoragePool)
    - one StorageCapabilities (+ its association to the StoragePool)
    - zero, one or multiple (StorageExtent)BasedOn(StorageExtent) associations
    - zero, one or multiple (StoragePool)AllocatedFrom(StoragePool)

    Different combinations are allowed, e.g. the primordial pool may have
    zero or multiple StorageExtents or logical volumes don't have StoragePools -
    just override appropriate enum* methods.

    There is usually only one instance per each DeviceWrapper subclass. All
    these instances are managed by WrapperManager.
    """
    
    def __init__(self, prefix):
        """
            :param prefix: prefix of StoragePool and StorageCapabilities
                InstanceIDs and CIM class names.
        """
        self.prefix = prefix
    
    @property
    def poolClassName(self):
        """
            CIM class name of device's CIM_StoragePool class.
            By default, Cura_<prefix>Pool.
            
            Override this method if different CIM class name is required.
        """
        return 'Cura_' + self.prefix + 'Pool'
    
    @property
    def extentClassName(self):
        """
            CIM class name of device's CIM_StorageExtent class.
            By default, Cura_<prefix>Extent.
            
            Override this method if different CIM class name is required.
        """
        return 'Cura_' + self.prefix + 'Extent'

    @property
    def associatedExtentClassName(self):
        """
            CIM class name of device's CIM_AssociatedComponentExtent class.
            By default, Cura_Associated<prefix>ComponentExtent.
            
            Override this method if different CIM class name is required.
        """
        return 'Cura_Associated' + self.prefix + 'ComponentExtent'
    
    @property
    def allocatedFromClassName(self):
        """
            CIM class name of device's CIM_AllocatedFromStoragePool class.
            By default, Cura_<prefix>AllocatedFromStoragePool.
            
            Override this method if different CIM class name is required.
        """
        return 'Cura_' + self.prefix + 'AllocatedFromStoragePool'

    @property
    def capabilitiesClassName(self):
        """
            CIM class name of device's CIM_StorageCapabilities class.
            By default, Cura_<prefix>StorageCapabilities.
            
            Override this method if different CIM class name is required.
        """
        return 'Cura_' + self.prefix + 'StorageCapabilities'

    @property
    def basedOnClassName(self):
        """
            CIM class name of device's CIM_BasedOn class.
            By default, Cura_<prefix>StorageCapabilities.
            
            Override this method if different CIM class name is required.
        """
        return 'Cura_' + self.prefix + 'ExtentBasedOn'

    @property
    def elementCapabilitiesClassName(self):
        """
            CIM class name of device's CIM_ElementCapabilities class.
            By default, Cura_<prefix>StorageElementCapabilities.
            
            Override this method if different CIM class name is required.
        """
        return 'Cura_' + self.prefix + 'StorageElementCapabilities'

    def getDevice(self, instanceName):
        """
            For given CIMInstanceName, it finds appropriate Anaconda device.
            The method returns None if such device cannot be found or the
            CIMInstanceName does not represent device managed by this wrapper
            or is malformed.
            
            :param instanceName: CIM instance name.
        """
        classname = instanceName.classname
        path = None
        if classname == self.poolClassName or classname == self.capabilitiesClassName: 
            try:
                (prefix, infix, path) = instanceName['InstanceID'].split(':')
            except ValueError:
                return None
            if prefix != self.prefix:
                return None
            if classname == self.poolClassName and infix != 'Pool':
                return None
            if classname == self.capabilitiesClassName and infix != 'Caps':
                return None
        elif classname == self.extentClassName:
            path = instanceName['DeviceID']
            if (instanceName['SystemName'] != CURA_SYSTEM_NAME or
                    instanceName['SystemCreationClassName'] !=CURA_SYSTEM_CLASS_NAME or
                    instanceName['CreationClassName'] != self.extentClassName):
                return None
        elif classname == self.associatedExtentClassName:
            group = instanceName['GroupComponent']
            part = instanceName['PartComponent']
            groupDevice = self.getDevice(group)
            partDevice = self.getDevice(part)
            if (groupDevice != partDevice):
                return None
            return groupDevice
        elif classname == self.allocatedFromClassName:
            pool = instanceName['Dependent']
            base = instanceName['Antecedent']
            device = self.getDevice(pool)
            baseWrapper = wrapperManager.getWrapperForInstance(base)
            baseDevice = baseWrapper.getDevice(base)
            for b in self.enumBaseDevices(device):
                if baseWrapper.getPoolId(b) == base['InstanceID']:
                    return (device, baseDevice)
            return None # not found in base devices
        elif classname == self.basedOnClassName:
            extent = instanceName['Dependent']
            base = instanceName['Antecedent']
            baseDevice = wrapperManager.getDevice(base)
            device = self.getDevice(extent)
            for b in self.enumBaseDevices(device):
                if b.path == baseDevice.path:
                    return (device, baseDevice)
            return None # not found in base devices
        elif classname == self.elementCapabilitiesClassName:
            managed = instanceName['ManagedElement']
            capabilities = instanceName['Capabilities']
            mdev = self.getDevice(managed)
            cdev = self.getDevice(capabilities)
            if mdev == cdev:
                return mdev
            return None # Managed and Capabilities do not match
        else:
            return None # unsupported classname
        
        if path:
            return storage.devicetree.getDeviceByPath(path)
        return None # device not found

    def enumDevices(self):
        """ 
            Enumerates all Anaconda devices managed by this wrapper,
            i.e. returns list (or generator) of all these devices.
            A StoragePool and StorageExtent is created for each such device.
            
            E.g. if this was RAID wrapper, all existing MD RAID devices
            known to Anaconda should be returned.
            
            **Subclasses must override this method.**
        """
        raise NotImplementedError()
    
    def enumBaseDevices(self, device):
        """ 
            Returns list (or generator) for all Anaconda base devices
            which are parents of given Anaconda device.
            
            E.g. if this was RAID wrapper, all members of given the RAID
            devices should be returned.
            
            :param device: Concrete Anaconda storage device to get list of
                parent devices from.
            
            **Subclasses must override this method.**
        """
        raise NotImplementedError()

    def getDeviceId(self, device):
        """
            Return StorageExtent.DeviceID for given Anaconda device.
            By default, it's device.path.
            
            Override this method if different DeviceID is required,
            but you must then override also getDevice() method.

            :param device: Concrete Anaconda storage device, whose DeviceID
                should be returned.
        """
        return device.path
    
    def getPoolId(self, device):
        """
            Return StoragePool.InstanceID for given Anaconda device.
            By default, it's <prefix>:Pool:<device.path>.
            
            Override this method if different InstanceID is required,
            but you must then override also getDevice() method.

            :param device: Concrete Anaconda storage device, whose InstanceID
                should be returned.

            Return None if there is no pool for given device (e.g. in LVWrapper).
        """
        return self.prefix + ':Pool:' + device.path
    
    def getPoolName(self, device):
        """
            Return CIMInstanceName of StoragePool for given Anaconda device.

            :param device: Concrete Anaconda storage device, whose StoragePool's
                CIMInstanceName should be returned.

            Return None if there is no pool for given device (e.g. in LVWrapper).

            It's not necessary to override this method, override getPoolId()
            instead.
        """
        poolId = self.getPoolId(device)
        if poolId is None:
            return None
        return pywbem.CIMInstanceName(classname=self.poolClassName, namespace=CURA_NAMESPACE,
                keybindings = {
                    'InstanceID' : poolId,
        })

    def enumPools(self,  env, model, keys_only):
        """
            Enumerate all StoragePools.

            :param env: Provider Environment (pycimmb.ProviderEnvironment).
            :param model: A template of the pywbem.CIMInstances to be generated.
            :param keys_only:  boolean. True if only the key properties should be
                set on the generated instances.

            It's not necessary to override this method, override enumDevices()
            instead.
        """
        for device in self.enumDevices():
            model.update(self.getPoolName(device).keybindings)
            if keys_only:
                yield model
            else:
                yield self.getPoolInstance(env, model, device)
    
    def getPoolInstance(self, env, model, device):
        """
            Fill and return a CIMInstance of StoragePool for given Anaconda
            device.

            :param env: Provider Environment (pycimmb.ProviderEnvironment).
            :param model: A template of the pywbem.CIMInstances to be generated.
            :param device: Concrete Anaconda storage device, whose StoragePool
                should be returned.

            **Subclasses must override this method.**
        """
        raise NotImplementedError()


    def getExtentName(self, device):
        """
            Return CIMInstanceName of StorageExtent for given Anaconda device.

            :param device: Concrete Anaconda storage device, whose
                StorageExtent's CIMInstanceName should be returned.

            It's not necessary to override this method, override getDeviceId()
            instead.
        """
        extentId = self.getDeviceId(device)
        if extentId is None:
            return None
        return pywbem.CIMInstanceName(classname=self.extentClassName, namespace=CURA_NAMESPACE,
                keybindings = {
                        'SystemName' : CURA_SYSTEM_NAME,    
                        'SystemCreationClassName': CURA_SYSTEM_CLASS_NAME,    
                        'CreationClassName': self.extentClassName,    
                         'DeviceID': extentId
                })
    
    def enumExtents(self,  env, model, keys_only):
        """
            Enumerate all StorageExtents.

            :param env: Provider Environment (pycimmb.ProviderEnvironment).
            :param model: A template of the pywbem.CIMInstances to be generated.
            :param keys_only:  boolean. True if only the key properties should be
                set on the generated instances.

            It's not necessary to override this method, override enumDevices()
            instead.
        """
        for device in self.enumDevices():
            model.update(self.getExtentName(device).keybindings)
            if keys_only:
                yield model
            else:
                yield self.getExtentInstance(env, model, device)
    
    def getExtentInstance(self, env, model, device):
        """
            Fill and return a CIMInstance of StorageExtent for given Anaconda
            device.

            :param env: Provider Environment (pycimmb.ProviderEnvironment).
            :param model: A template of the pywbem.CIMInstances to be generated.
            :param device: Concrete Anaconda storage device, whose StorageExtent
                should be returned.

            **Subclasses must override this method.**
        """
        raise NotImplementedError()



    def getCapabilitiesId(self, device):
        """
            Return StorageCapabilities.InstanceID for given Anaconda device.
            By default, it's <prefix>:Caps:<device.path>.
            
            Override this method if different InstanceID is required,
            but you must then override also getDevice() method.

            :param device: Concrete Anaconda storage device, whose InstanceID
                should be returned.

            Return None if there is no pool for given device (e.g. in LVWrapper).
        """
        return self.prefix + ':Caps:' + device.path
    
    def getCapabilitiesName(self, device):
        """
            Return CIMInstanceName of StorageCapabilities for given Anaconda
            device.

            :param device: Concrete Anaconda storage device, whose
                StorageCapabilities's CIMInstanceName should be returned.

            It's not necessary to override this method, override getCapabilitiesId()
            instead.

            Return None if there is no pool for given device (e.g. in LVWrapper).
        """
        return pywbem.CIMInstanceName(classname=self.capabilitiesClassName, namespace=CURA_NAMESPACE,
                keybindings = {
                    'InstanceID' : self.getCapabilitiesId(device),
        })
        
    def enumCapabilities(self, env, model, keys_only):
        """
            Enumerate all StorageCapabilities.

            :param env: Provider Environment (pycimmb.ProviderEnvironment).
            :param model: A template of the pywbem.CIMInstances to be generated.
            :param keys_only:  boolean. True if only the key properties should be
                set on the generated instances.

            It's not necessary to override this method, override enumDevices()
            instead.
        """
        for device in self.enumDevices():
            model.update(self.getCapabilitiesName(device).keybindings)
            if keys_only:
                yield model
            else:
                yield self.getCapabilitiesInstance(env, model, device)
        
    def getCapabilitiesInstance(self, env, model, device):
        """
            Fill and return a CIMInstance of StorageCapabilities for given
            Anaconda device.

            :param env: Provider Environment (pycimmb.ProviderEnvironment).
            :param model: A template of the pywbem.CIMInstances to be generated.
            :param device: Concrete Anaconda storage device, whose
                StorageCapabilities should be returned.

            It's not necessary to override this method, override getParameters()
            instead.
        """
        params = self.getParameters(device)
        model['DataRedundancyDefault'] = params['DataRedundancyDefault'] 
        model['DataRedundancyMax'] = params['DataRedundancyMax']
        model['DataRedundancyMin'] =  params['DataRedundancyMin']
        model['ElementName'] = model['InstanceID']
        model['ElementType'] = WrappedStorageCapabilities.Values.ElementType.StoragePool
        model['ExtentStripeLengthDefault'] =  params['ExtentStripeLengthDefault']
        model['NoSinglePointOfFailure'] = params['NoSinglePointOfFailure']
        model['NoSinglePointOfFailureDefault'] = params['NoSinglePointOfFailureDefault']
        model['PackageRedundancyDefault'] = params['PackageRedundancyDefault']
        model['PackageRedundancyMax'] = params['PackageRedundancyMax']
        model['PackageRedundancyMin'] = params['PackageRedundancyMin']
        return model

    def enumAssociatedExtents(self, env, model, keys_only):
        """
            Enumerate all AssociatedComponentExtents.

            :param env: Provider Environment (pycimmb.ProviderEnvironment).
            :param model: A template of the pywbem.CIMInstances to be generated.
            :param keys_only:  boolean. True if only the key properties should be
                set on the generated instances.

            It's not necessary to override this method, override enumDevices()
            instead.
        """
        for device in self.enumDevices():
            pool = self.getPoolName(device)
            extent = self.getExtentName(device)
            if pool is None or extent is None:
                continue
            model['GroupComponent'] = pool
            model['PartComponent'] = extent
            yield model

    def getAssociatedExtentInstance(self, env, model, device):
        """
            Fill and return a CIMInstance of AssociatedComponentExtent
            for given Anaconda device.

            :param env: Provider Environment (pycimmb.ProviderEnvironment).
            :param model: A template of the pywbem.CIMInstances to be generated.
            :param device: Concrete Anaconda storage device, whose
                AssociatedComponentExtent should be returned.

            It's not necessary to override this method.
        """
        # TODO: just checks
        return model
        
    
    def enumAllocatedFroms(self, env, model, keys_only):
        """
            Enumerate all AllocatedFrom(StoragePool).

            :param env: Provider Environment (pycimmb.ProviderEnvironment).
            :param model: A template of the pywbem.CIMInstances to be generated.
            :param keys_only:  boolean. True if only the key properties should be
                set on the generated instances.

            It's not necessary to override this method, override enumDevices()
            and enumBaseDevices() instead.
        """
        reported = []
        for device in self.enumDevices():
            for base in self.enumBaseDevices(device):
                pool = self.getPoolName(device)
                dependentWrapper = wrapperManager.getWrapperForDevice(base)
                basePool = dependentWrapper.getPoolName(base)
                if pool is None or basePool is None:
                    continue
                model['Dependent'] = pool
                model['Antecedent'] = basePool
                instanceId = model['Antecedent']['InstanceID']
                if instanceId in reported:
                    continue
                reported.append(instanceId)
                if keys_only:
                    yield model
                else:
                    yield self.getAllocatedFromInstance(env, model, device, base)

    def getAllocatedFromInstance(self, env, model, device, base):
        """
            Fill and return a CIMInstance of AllocatedFrom(StoragePool) for
            given Anaconda device.

            :param env: Provider Environment (pycimmb.ProviderEnvironment).
            :param model: A template of the pywbem.CIMInstances to be generated.
            :param device: Concrete Anaconda storage device, whose
                ElementCapabilities should be returned.

            **Subclasses must override this method.**
        """
        raise NotImplementedError()

    def enumElementCapabilities(self, env, model, keys_only):
        """
            Enumerate all ElementCapabilities.

            :param env: Provider Environment (pycimmb.ProviderEnvironment).
            :param model: A template of the pywbem.CIMInstances to be generated.
            :param keys_only:  boolean. True if only the key properties should be
                set on the generated instances.

            It's not necessary to override this method, override enumDevices()
            instead.
        """
        for device in self.enumDevices():
            pool = self.getPoolName(device)
            caps = self.getCapabilitiesName(device)
            if pool is None or caps is None:
                continue
            model['ManagedElement'] = pool
            model['Capabilities'] = caps
            yield model

    def getElementCapabilitiesInstance(self, env, model, device):
        """
            Fill and return a CIMInstance of ElementCapabilities
            for given Anaconda device.

            :param env: Provider Environment (pycimmb.ProviderEnvironment).
            :param model: A template of the pywbem.CIMInstances to be generated.
            :param device: Concrete Anaconda storage device, whose
                ElementCapabilities should be returned.

            It's not necessary to override this method.
        """
        # TODO checks
        return model

    def enumBasedOns(self, env, model, keys_only):
        """
            Enumerate all BasedOn associations.

            :param env: Provider Environment (pycimmb.ProviderEnvironment).
            :param model: A template of the pywbem.CIMInstances to be generated.
            :param keys_only:  boolean. True if only the key properties should be
                set on the generated instances.

            It's not necessary to override this method, override enumDevices()
            and enumBaseDevices() instead.
        """
        for device in self.enumDevices():
            for base in self.enumBaseDevices(device):
                extent = self.getExtentName(device)
                dependentWrapper = wrapperManager.getWrapperForDevice(base)
                baseExtent = dependentWrapper.getExtentName(base)
                if extent is None or baseExtent is None:
                    continue
                model['Dependent'] = extent
                model['Antecedent'] = baseExtent
                if keys_only:
                    yield model
                else:
                    yield self.getBasedOnInstance(env, model, device, base)

    def getBasedOnInstance(self, env, model, device, base):
        """
            Fill and return a CIMInstance of BasedOn for
            given Anaconda device.

            :param env: Provider Environment (pycimmb.ProviderEnvironment).
            :param model: A template of the pywbem.CIMInstances to be generated.
            :param device: Concrete Anaconda storage device, whose
                BasedOn should be returned.

            **Subclasses must override this method.**
        """
        raise NotImplementedError()

    def getParameters(self, device):
        """
            Return hash of properties to be added to StorageCapabilities or
            StorageSettings or StorageExtent.

            The redundancy features of the StorageCapabilities should be set
            in *Default. It is assumed that *Min == *Max == *Default, e.g.
            DataRedundancyMin == DataRedundancyMax == DataRedundancyDefault.
            
            :param device: Concrete Anaconda storage device, whose
                storage parameters should be returned.

            **Subclasses should override this method.**
        """
        params = {
                'Name': device.path,
                'Primordial': False
        }
        if device.partedDevice:
            params.update({
                    'NumberOfBlocks': pywbem.Uint64(device.partedDevice.length),
                    'ConsumableBlocks': pywbem.Uint64(device.partedDevice.length),
                    'BlockSize': pywbem.Uint64(device.partedDevice.sectorSize),
            })
        return params

    def wrapsDevice(self, device):
        """
            Return True, if given Anaconda storage device is managed by this
            wrapper.

            :param device: Concrete Anaconda storage device, whose
                storage parameters should be returned.

            **Subclasses must override this method.**
        """
        raise NotImplementedError()

    # useful constats for StorageSetting.CuraAllocationType
    ALLOCATION_TYPE_ONE = 1
    ALLOCATION_TYPE_MULTIPLE = 0
        
    
    def canCreatePool(self, devices, setting, size = None, name = None):
        """
            Check, if this DeviceWrapper is able to create new pool, i.e.
            new Anaconda storage device, from given devices, setting, size
            and name.
            
            Only quick of given setting is expected if it applies to this
            wrapper.
            
            **This method tells, if this wrapper will be in charge of the
            created pool. It may be different to wrappers, that manage the
            input devices!**
            
            Size should not be checked, it is provided for information only!
            There is special return code from createPool(), which tells
            application that the provided size is wrong.
            
            Return 0, when this wrapper is not able to create such pool, and
            positive integer, when the wrapper can create the pool. The integer
            value is taken as priority, the wrapper, which returns the highest
            number, will be then asked to create the pool using createPool().
            
            :param devices: Array of Anaconda storage devices representing
                 input StoragePools and StorageExtents.
            :param setting: Instance of Cura_StorageSetting.
            :param size: Expected size of the resulting device.
            :param name: Expected name of the resulting device.
            
            The input parameters are taken from
            Cura_StorageConfigurationService.CreateOrModifyStoragePool

            **Subclasses must override this method.**
        """
        return 0

    CREATE_POOL_SIZE_NOT_SUPPORTED = pywbem.Uint32(4097)
    CREATE_POOL_COMPLETED = pywbem.Uint32(0)
        
    def createPool(self, devices, setting, size = None, name = None):
        """
            Create new pool, i.e. new Anaconda storage device from given
            source devices, setting and (optionally) size and name.
            
            :param devices: Array of Anaconda storage devices representing
                 input StoragePools and StorageExtents.
            :param setting: Instance of Cura_StorageSetting.
            :param size: Expected size of the resulting device.
            :param name: Expected name of the resulting device.

            Return tuple (return_code, device, size), where
            
            # return_code is pywbem error code, e.g.
                pywbem.CIM_ERR_INVALID_PARAMETER.
            # device is created device or None on error.
            # size is size of the created device or, when input size parameter
                was wrong, nearest size of the device that could be created
                from provided devices.
                
            The input parameters are taken from
            Cura_StorageConfigurationService.CreateOrModifyStoragePool

            **Subclasses must override this method.**
        """
        raise NotImplementedError()

    CREATE_DISK_SIZE_NOT_SUPPORTED = pywbem.Uint32(4097) #Cura_StorageConfigurationService.Values.CreateOrModifyElementFromStoragePool.Size_Not_Supported
    CREATE_DISK_COMPLETED_OK = pywbem.Uint32(0)


    def _checkSetting(self, setting, minParam, maxParam, goalParam, available):
        """
            Compare one property of StorageCapabilities with StorageSetting.
            Return True, if a LogicalDisk with given StorageSetting can be
            created from the StoragePool with given StorageCapabilities, i.e.
            that *Min, Max and Goal properties of the setting can be applied
            to the given capabilities.
            
            :param setting: CIM Instance of Cura_StorageSetting.
            :param minParam: Name of *Min property of the setting, e.g.
                'DataRedundancyMin'.
            :param maxParam: Name of *Max property of the setting, e.g.
                'DataRedundancyMax'.
            :param maxParam: Name of *Max property of the setting, e.g.
                'DataRedundancyMax'.
            :param goalParam: Name of *Goal property of the setting, e.g.
                'DataRedundancyGoal'.
            :patam available: Value of appropriate property (e.g.
                DataRedundancyDefault) of the StorageCapabilities.
        """
        minValue = setting.get(minParam, None)
        maxValue = setting.get(maxParam, None)
        goalValue = setting.get(goalParam)
        
        if goalValue:
            if goalValue == available:
                # The pool provides the *Goal property
                return True
            if not maxValue and not minValue:
                # only *Goal is specified and it's different to the requested one
                return False
        
        if minValue and minValue > available:
            # The pool cannot satisfy *Min property
            return False
            
        if maxValue and maxValue < available:
            # The pool cannot satisfy *Max property
            return False
        
        return True
        
        
    def createLogicalDisk(self, device, setting, size, name = None):
        """
            Allocate a CIM_LogicalDisk from a pool represented by given
            Anaconda device.
            
            :param setting: Instance of Cura_StorageSetting.
            :param device: Anaconda storage device, representing the pool to
                allocate from. The pool is managed by this wrapper.
            :param size: Expected size of the resulting LogicalDisk.
            :param name: Expected name of the resulting LogicalDisk.
            
            Return tuple (return_code, element, size), where
            
            # return_code is DeviceWrapper.CREATE_DISK_*
            # element is CIMInstanceName of created LogicalDisk or None on
                error.
            # size is size of the created LogicalDisk or, when input size
                parameter was wrong, the nearest size of the device that could
                be created from provided pool.

            The input parameters are taken from
            Cura_StorageConfigurationService.CreateOrModifyElementFromStoragePool

            The default implementation just creates new auxiliar
            Cura_LogicalDisk instance. This instance is persistent, i.e.
            survives Cura restart. Only whole device can be allocated,
            
            Override this method, if different behavior is expected (e.g.
            when allocating LogicalVolumes).
        """
        if name is not None:
            raise pywbem.CIMError(pywbem.CIM_ERR_FAILED,
                'ElementName is not supported for allocation from this pool.')
        if logicalDiskManager.isExposed(device) or logicalDiskManager.isUsed(device):
            raise pywbem.CIMError(pywbem.CIM_ERR_FAILED, 'No free space in the pool.')
        deviceSize = device.partedDevice.length * device.partedDevice.sectorSize
        if size is not None and size != deviceSize:
            return (self.CREATE_DISK_SIZE_NOT_SUPPORTED, None, deviceSize)

        # check the settings
        if setting:
            wrapper = wrapperManager.getWrapperForDevice(device)
            deviceparams = wrapper.getParameters()
            if not _checkSetting(setting, 'DataRedundancyMin', 'DataRedundancyMax', 'DataRedundancyGoal', deviceparams['DataRedundancyDefault']):
                raise pywbem.CIMError(pywbem.CIM_ERR_INVALID_PARAMETER, 'Wrong Goal: the DataRedundancy* values are not supported by this pool.')
            if not _checkSetting(setting, 'PackageRedundancyMin', 'PackageRedundancyMax', 'PackageRedundancyGoal', deviceparams['PackageRedundancyDefault']):
                raise pywbem.CIMError(pywbem.CIM_ERR_INVALID_PARAMETER, 'Wrong Goal: the PackageRedundancy* values are not supported by this pool.')
            nspof = setting.get('NoSinglePointOfFailure', None)
            if nspof and not deviceparams['NoSinglePointOfFailure']:
                raise pywbem.CIMError(pywbem.CIM_ERR_INVALID_PARAMETER, 'Wrong Goal: the NoSinglePointOfFailure values are not supported by this pool.')
                        
        # expose the device
        logicalDiskManager.setExpose(device, True)
        # compute TheElement return value
        element = pywbem.CIMInstanceName(classname='Cura_LogicalDisk', namespace=CURA_NAMESPACE,
                keybindings = {"SystemName" : CURA_SYSTEM_NAME,
                    "SystemCreationClassName" : CURA_SYSTEM_CLASS_NAME,
                    "CreationClassName" : 'Cura_LogicalDisk',
                    "DeviceID" : device.path
                })
        return (self.CREATE_DISK_COMPLETED_OK, element, deviceSize)

    DESTROY_COMPLETED_OK = pywbem.Uint32(0)
    
    def destroyPool(self, device):
        """
            Destroy given pool, i.e. the Anaconda device. It is assumed
            that the device is empty, i.e. no other device is BasedOn or
            AllocatedFrom it.
            
            :param device: The device to destroy.
            
            By default, it just removes the device from Anaconda's device
            tree and lets Anaconda do its job. Override this
            method if different behaviour is desired for particular Anaconda
            device type,
        """
        if logicalDiskManager.isUsed(device) or logicalDiskManager.isExposed(device):
            raise pywbem.CIMError(pywbem.CIM_ERR_FAILED, 'The pool is used.')
        action = pyanaconda.storage.deviceaction.ActionDestroyDevice(device)
        storage.devicetree.registerAction(action)
        action.execute()
        storage.devicetree._actions = []
        return self.DESTROY_COMPLETED_OK

    def destroyLogicalDisk(self, device):
        """
            Destroy given LogicalDisk, allocated from pool wrapped by this
            wrapper. If there is a filesystem on the device, this method
            should remove it.
            
            :param device; Anaconda storage device, representing the
                LogicalDisk. It is usually the same device as the pool it
                is allocated from - by default, we create LogicalDisks
                only for whole StoragePools.
                
            The default implementation just removes filesystem (if any)
            and removes the device from list of exposed LogicalDisks.
            
            Overridde this method if different behavious is desired.
        """
        if not logicalDiskManager.isExposed(device):
            raise pywbem.CIMError(pywbem.CIM_ERR_INVALID_PARAMETER, 'The element is not logical disk.')
            
        if device.format.type is not None:
            action = pyanaconda.storage.deviceaction.ActionDestroyFormat(device)
            storage.devicetree.registerAction(action)
            action.execute()
            storage.devicetree._actions = []
            
        logicalDiskManager.setExpose(device, False)
        return self.DESTROY_COMPLETED_OK

    def calculateCommonBaseParams(self, device):
        """
            Return the least common denominator of all device's base
            getParameters() values.
            
            :param device: Anaconda storage device, whose parent devices
                should be evaluated.
        """
        current = None
        for base in self.enumBaseDevices(device):
            baseWrapper = wrapperManager.getWrapperForDevice(base)
            params = baseWrapper.getParameters(base)
            if current is None:
                current = params
                current['DataRedundancyMin'] = params['DataRedundancyDefault']
                current['DataRedundancyMax'] = params['DataRedundancyDefault']
                current['PackageRedundancyMin'] = params['PackageRedundancyDefault']
                current['PackageRedundancyMax'] = params['PackageRedundancyDefault']
                current['NoSinglePointOfFailure'] = params['NoSinglePointOfFailureDefault']
                continue
            
            if current['DataRedundancyMin'] < params['DataRedundancyDefault']:
                current['DataRedundancyMin'] = params['DataRedundancyDefault']
            if current['DataRedundancyMax'] > params['DataRedundancyDefault']:
                current['DataRedundancyMax'] = params['DataRedundancyDefault']
            if current['DataRedundancyDefault'] > params['DataRedundancyDefault']:
                current['DataRedundancyDefault'] = params['DataRedundancyDefault']

            if current['PackageRedundancyMin'] < params['PackageRedundancyDefault']:
                current['PackageRedundancyMin'] = params['PackageRedundancyDefault']
            if current['PackageRedundancyMax'] > params['PackageRedundancyDefault']:
                current['PackageRedundancyMax'] = params['PackageRedundancyDefault']
            if current['PackageRedundancyDefault'] > params['PackageRedundancyDefault']:
                current['PackageRedundancyDefault'] = params['PackageRedundancyDefault']
                
            if current['NoSinglePointOfFailureDefault'] > params['NoSinglePointOfFailureDefault']:
                current['NoSinglePointOfFailureDefault'] = params['NoSinglePointOfFailureDefault']

            if current['NoSinglePointOfFailure'] > params['NoSinglePointOfFailureDefault']:
                current['NoSinglePointOfFailure'] = params['NoSinglePointOfFailureDefault']

            if current['IsBasedOnUnderlyingRedundancy'] > params['IsBasedOnUnderlyingRedundancy']:
                current['IsBasedOnUnderlyingRedundancy'] = params['IsBasedOnUnderlyingRedundancy']                
        return current
            